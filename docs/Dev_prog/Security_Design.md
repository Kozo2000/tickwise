# Tickwise セキュリティ設計

Tickwiseは、投資分析ツールとしての信頼性を確保するため、データの安全性、計算の一貫性、およびシステムの可用性に重点を置いた設計を行っています。

本ドキュメントでは、情報のセキュリティ特性である「CIA（機密性・完全性・可用性）」に基づき、Tickwiseの実装方針を詳述します。特に、分析ツールの根幹となる「正確性」を最優先事項として再定義し、以下の通り実装しています。

---

## 1. 完全性（Integrity）：データの一貫性と正確性の担保
分析結果の信頼性を維持するため、**単一の信頼可能な情報源（SOT: Source of Truth）**に基づいた設計を採用しています。

#### ● 構造体 `TechnicalDataGuard` によるアクセス制御
指標データの操作は、専用のラッパー構造体 `TechnicalDataGuard` を通じて制御されます。
- **直接アクセスの制限:** 内部データ構造体への直接的な読み書きを制限し、必ずガード（ラッパー）を経由するよう強制しています。これにより、意図しないデータの書き換えや不整合の発生を構造的に防止します。
- **インターフェースの限定:** 各処理に応じた最小限のリード/ライトインターフェースのみを提供し、データの整合性を維持します。

#### ● 独自演算と標準ライブラリの併用による計算精度
計算結果の信頼性を維持するため、以下の設計を採用しています。
- **一回限りの計算実行:** 各指標の計算は実行サイクル中に一度のみ行われます。計算済みデータを共通利用することで、出力形式（画面、ログ、LLM用プロンプト等）によらず、一貫した数値を提供します。
- **標準ライブラリ `ta` クレートの利用:** RSI、MACD、EMAなどの基本的な指標には、コミュニティで広く検証されている `ta` クレートを採用し、再現性を確保しています。
- **独自演算（Proprietary Arithmetic）の検証:** `ta` クレートで提供されていない、または仕様に基づいた調整が必要な指標（ADX、ストキャスティクス、フィボナッチ、VWAP、一目均衡表等）については、透明性を確保した算術式を実装しています。
- **エラー値への対応:** 独自演算において、値幅がゼロ（`high == low`）の場合のゼロ除算回避や、判定境界における丸め処理（eps）を実装しています。これにより、数値計算の破綻を回避し、安全な代替値（中立スコア等）を算出します。
- **数値チェック:** スコア計算および重み付けの過程で、`f64::is_finite()` による有限性チェックと `clamp()` による範囲制約を適用し、極端な数値によるロジックの不安定化を防止しています。
- **精度の統一:** 浮動小数点に関して、すべての内部演算を `f64` に統一し、型変換に伴う精度低下を最小限に抑えています。
- **データ鮮度の管理:** 取引所の更新時刻を考慮した取得ロジックにより、最新の市場データに基づいた分析結果を出力します。

> 各指標の詳細なロジックについては、以下のガイドを参照してください。
> 👉 [Tickwise 指標・スコア解説ガイド](../manual/indicator-guide.md)

---

## 2. 機密性（Confidentiality）：機密データの保護
APIキーなどの機密情報およびユーザー環境の保護を徹底しています。

#### ● OS上の一メンバーとしての設計（Rustの活用）
- **メモリ安全性:** Rustの型システムと所有権モデルにより、メモリリークやセグメントエラーを未然に防止します。システムのリソースを安全に利用し、他のプロセスに悪影響を与えない実装を行っています。
- **境界サニタイズの徹底:** ティッカー記号、ニュースクエリ、ファイルパス等の外部入力に対し、許可文字の制限（英数字制限等）や制御文字の排除（セミコロン、パイプ等）を行い、インジェクション等の攻撃リスクを低減しています。
- **ファイルパスの解決:** すべてのファイルアクセスにおいて、パスの正規化や存在チェックを実施。想定外のディレクトリへの書き込みや読み込みを構造的に防御します。

#### ● APIキーの管理と廃棄
APIキーは重要な資産であり、その露出時間を最小化する設計を施しています。
- **オンデマンド展開:** APIキーは定常的にメモリに保持せず、リクエスト構築の直前にのみ取得します。
- **ゼロ化廃棄（Zeroize）:** 利用後のAPIキーが含まめるメモリ領域は、直ちに `zeroize`（ゼロパディング）処理を行い、物理的に廃棄します。これにより、予期せぬメモリダンプやトレースによるキー情報の流出を防止します。
- **露出の構造的遮断:** デバッグ出力やログ、内部構造体からAPIキーが露出しないようマスク処理を徹底しています。

#### ● ソフトウェア・サプライチェーンの透明性
####  サプライチェーン・リスクの低減 (`cargo audit`)
依存ライブラリに潜む既知の脆弱性リスクを管理するため、RustSec アドバイザリデータベースを用いたスキャンを開発工程に組み込んでいます。

- **継続的な検証**: 全依存ライブラリ（現時点で 240 以上）に対し、定期的に `cargo audit` を実行し、脆弱性が報告された場合の対応体制を維持しています。
- **スキャン結果の公開**: 開発時点でのスキャン結果を公開することで、依存関係の透明性を確保しています。

```text
(開発環境での実行例)
Scanning Cargo.lock for vulnerabilities (243 crate dependencies)
Success: No vulnerabilities found.
```

#### SBOM (Software Bill of Materials) の提供
- CycloneDX形式による組成情報の生成をサポートし、使用コンポーネントの透明性を確保しています。

#### 注意事項：APIキーのオプション指定について
コマンドライン引数（`--brave-api-key` 等）によるAPIキーの指定は推奨されません。コマンド履歴にキー情報が残るリスクがあるため、設定ファイル（`tickwise.env`）の利用を推奨します。

---

## 3. 可用性（Availability）：堅牢なシステム実行
不測の事態においても分析処理を継続するための設計です。

#### ● 堅牢なエラーハンドリング（Robustness）
- **`unwrap` の制限:** 予期せぬ終了を避けるため、エラーチェックを構造化しています。異常な環境下でも安全に処理を終了、あるいは継続できる実装を追求しています。
- **レジリエンス（回復性）:** APIの応答遅延や設定不備に対し、安全なデフォルト動作を定義することで、ユーザーの分析作業を妨げない可用性を維持します。

---

## まとめ
Tickwiseのセキュリティ設計は、技術的根拠に基づいた一貫性のある実装を目指しています。

計算の唯一性、検証済みの演算ロジック、Rustによるシステム保護、および徹底したメモリ管理は、ユーザーが安全に分析を実行するための基盤として機能します。客観的な事実に基づき、信頼性の高い投資分析環境を提供することが本プロジェクトの設計指針です。
